{
  "id": "guide/forms-overview",
  "title": "Introduction to forms in Angular",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/forms-overview.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"introduction-to-forms-in-angular\">Introduction to forms in Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#introduction-to-forms-in-angular\"><i class=\"material-icons\">link</i></a></h1>\n<p translation-origin=\"off\">Handling user input with forms is the cornerstone of many common applications. Applications use forms to enable users log in, to update a profile, to enter sensitive information, and to perform many other data-entry tasks. </p>\n<p translation-origin=\"off\">Angular provides two different approaches to handling user input through forms: reactive and template-driven. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes. </p>\n<p translation-origin=\"off\">Reactive and template-driven forms differ, however, in how they do the work of processing and managing forms and form data. Each offers different advantages.</p>\n<p translation-origin=\"off\"><strong>In general:</strong></p>\n<ul>\n<li><strong>Reactive forms</strong> are more robust: they are more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms.</li>\n<li><strong>Template-driven forms</strong> are useful for adding a simple form to an app, such as an email list signup form. They are easy to add to an app, but they do not scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, use template-driven forms.</li>\n</ul>\n<p translation-origin=\"off\">This guide provides information to help you decide which approach works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing.</p>\n<div class=\"alert is-important\">\n<p translation-origin=\"off\"><em>Note:</em> For complete information about each kind of form, see the <a href=\"guide/reactive-forms\">Reactive Forms</a> and <a href=\"guide/forms\">Template-driven Forms</a> guides.</p>\n</div>\n<h2 translation-origin=\"off\" id=\"key-differences\">Key differences<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#key-differences\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">The table below summarizes the key differences between reactive and template-driven forms.</p>\n<style>\n  table {width: 100%};\n  td, th {vertical-align: top};\n</style>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Reactive</th>\n<th>Template-driven</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Setup (form model)</td>\n<td>More explicit, created in the component class.</td>\n<td>Less explicit, created by the directives.</td>\n</tr>\n<tr>\n<td>Data model</td>\n<td>Structured</td>\n<td>Unstructured</td>\n</tr>\n<tr>\n<td>Predictability</td>\n<td>Synchronous</td>\n<td>Asynchronous</td>\n</tr>\n<tr>\n<td>Form validation</td>\n<td>Functions</td>\n<td>Directives</td>\n</tr>\n<tr>\n<td>Mutability</td>\n<td>Immutable</td>\n<td>Mutable</td>\n</tr>\n<tr>\n<td>Scalability</td>\n<td>Low-level API access</td>\n<td>Abstraction on top of APIs</td>\n</tr>\n</tbody>\n</table>\n<h2 translation-origin=\"off\" id=\"common-foundation\">Common foundation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#common-foundation\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Both reactive and template-driven forms share underlying building blocks. </p>\n<ul>\n<li>A <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance that tracks the value and validation status of an individual form control.</li>\n<li>A <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> instance that tracks the same values and status for a collection of form controls.</li>\n<li>A <code><a href=\"api/forms/FormArray\" class=\"code-anchor\">FormArray</a></code> instance that tracks the same values and status for an array of form controls.</li>\n<li>A <code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code> that creates a bridge between Angular <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instances and native DOM elements.</li>\n</ul>\n<p translation-origin=\"off\">How these control instances are created and managed with reactive and template-driven forms is introduced in the <a href=\"guide/forms-overview#setup-the-form-model\">form model setup</a> section below and detailed further in the <a href=\"guide/forms-overview#data-flow-in-forms\">data flow section</a> of this guide.</p>\n<h2 translation-origin=\"off\" id=\"setup-the-form-model\">Setup: The form model<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-the-form-model\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Reactive and template-driven forms both use a form model to track value changes between Angular forms and form input elements.  The examples below show how the form model is defined and created.</p>\n<h3 translation-origin=\"off\" id=\"setup-in-reactive-forms\">Setup in reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">Here is a component with an input field for a single control implemented using reactive forms.</p>\n<code-example path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a> } from '@angular/forms';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-reactive-favorite-color',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    Favorite Color: &#x3C;input type=\"text\" [formControl]=\"favoriteColorControl\">\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('');\n}\n\n\n</code-example>\n<p translation-origin=\"off\">The source of truth provides the value and status of the form element at a given point in time. In reactive forms, the form model is source of truth. The form model in the above example is the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</p>\n<figure>\n  <img src=\"generated/images/guide/forms-overview/key-diff-reactive-forms.png\" alt=\"Reactive forms key differences\" width=\"635\" height=\"335\">\n</figure>\n<p translation-origin=\"off\">With reactive forms, the form model is explicitly defined in the component class. The reactive form directive (in this case, <code><a href=\"api/forms/FormControlDirective\" class=\"code-anchor\">FormControlDirective</a></code>) then links the existing form control instance to a specific form element in the view using a value accessor (instance of <code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code>). </p>\n<h3 translation-origin=\"off\" id=\"setup-in-template-driven-forms\">Setup in template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">Here is the same component with an input field for a single control implemented using template-driven forms.</p>\n<code-example path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-template-favorite-color',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    Favorite Color: &#x3C;input type=\"text\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"favoriteColor\">\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}\n\n\n</code-example>\n<p translation-origin=\"off\">In template-driven forms, the source of truth is the template.</p>\n<figure>\n  <img src=\"generated/images/guide/forms-overview/key-diff-td-forms.png\" alt=\"Template-driven forms key differences\" width=\"607\" height=\"387\">\n</figure>\n<p translation-origin=\"off\">The abstraction of the form model promotes simplicity over structure. The template-driven form directive <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> is responsible for creating and managing the form control instance for a given form element. It is less explicit, but you no longer have direct control over the form model. </p>\n<h2 translation-origin=\"off\" id=\"data-flow-in-forms\">Data flow in forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-forms\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">When building forms in Angular, it's important to understand how the framework handles data flowing from the user or from programmatic changes. Reactive and template-driven forms follow two different strategies when handling form input. The data flow examples below begin with the favorite color input field example from above, and they show how changes to favorite color are handled in reactive forms compared to template-driven forms.</p>\n<h3 translation-origin=\"off\" id=\"data-flow-in-reactive-forms\">Data flow in reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">As described above, in reactive forms each form element in the view is directly linked to a form model (<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance). Updates from the view to model and model to view are synchronous and not dependent on the UI rendered. The diagrams below use the same favorite color example to demonstrate how data flows when an input field's value is changed from the view and then from the model.</p>\n<figure>\n  <img src=\"generated/images/guide/forms-overview/dataflow-reactive-forms-vtm.png\" alt=\"Reactive forms data flow - view to model\" width=\"100%\">\n</figure>\n<p translation-origin=\"off\">The steps below outline the view to model data flow.</p>\n<ol>\n<li>The end user types a value into the input element, in this case the favorite color \"Blue\".</li>\n<li>The form input element emits an \"input\" event with the latest value.</li>\n<li>The control value accessor listening for events on the form input element immediately relays the new value to the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</li>\n<li>The <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance emits the new value through the <code>valueChanges</code> observable.</li>\n<li>Any subscribers to the <code>valueChanges</code> observable receive the new value.</li>\n</ol>\n<figure>\n  <img src=\"generated/images/guide/forms-overview/dataflow-reactive-forms-mtv.png\" alt=\"Reactive forms data flow - model to view\" width=\"100%\">\n</figure>\n<p translation-origin=\"off\">The steps below outline the model to view data flow.</p>\n<ol>\n<li>The <code>favoriteColorControl.setValue()</code> method is called, which updates the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> value.</li>\n<li>The <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance emits the new value through the <code>valueChanges</code> observable.</li>\n<li>Any subscribers to the <code>valueChanges</code> observable receive the new value.</li>\n<li>The control value accessor on the form input element updates the element with the new value.</li>\n</ol>\n<h3 translation-origin=\"off\" id=\"data-flow-in-template-driven-forms\">Data flow in template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">In template-driven forms, each form element is linked to a directive that manages the form model internally. The diagrams below uses the same favorite color example to demonstrate how data flows when an input field's value is changed from the view and then from the model.</p>\n<figure>\n  <img src=\"generated/images/guide/forms-overview/dataflow-td-forms-vtm.png\" alt=\"Template-driven forms view to model data flow\" width=\"100%\">\n</figure>\n<p translation-origin=\"off\">The steps below outline the view to model data flow.</p>\n<ol>\n<li>The end user types \"Blue\" into the input element.</li>\n<li>The input element emits an \"input\" event with the value \"Blue\".</li>\n<li>The control value accessor attached to the input triggers the <code>setValue()</code> method on the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</li>\n<li>The <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance emits the new value through the <code>valueChanges</code> observable.</li>\n<li>Any subscribers to the <code>valueChanges</code> observable receive the new value.</li>\n<li>The control value accessor also calls the <code><a href=\"api/forms/NgModel#viewToModelUpdate\" class=\"code-anchor\">NgModel.viewToModelUpdate()</a></code> method which emits an <code>ngModelChange</code> event.</li>\n<li>Because the component template uses two-way data binding for the <code>favoriteColor</code>, the <code>favoriteColor</code> property in the component\nis updated to the value emitted  by the <code>ngModelChange</code> event (\"Blue\").</li>\n</ol>\n<figure>\n  <img src=\"generated/images/guide/forms-overview/dataflow-td-forms-mtv.png\" alt=\"Template-driven forms model to view data flow\" width=\"100%\">\n</figure>\n<p translation-origin=\"off\">The steps below outline the model to view data flow.</p>\n<ol>\n<li>The <code>favoriteColor</code> value is updated in the component.</li>\n<li>Change detection begins.</li>\n<li>During change detection, the <code>ngOnChanges</code> lifecycle hook is called on the <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> directive instance because the value of one of its inputs has changed.</li>\n<li>The <code>ngOnChanges()</code> method queues an async task to set the value for the internal <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</li>\n<li>Change detection completes.</li>\n<li>On the next tick, the task to set the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance value is executed.</li>\n<li>The <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance emits the latest value through the <code>valueChanges</code> observable.</li>\n<li>Any subscribers to the <code>valueChanges</code> observable receive the new value.</li>\n<li>The control value accessor updates the form input element in the view with the latest <code>favoriteColor</code> value.</li>\n</ol>\n<h2 translation-origin=\"off\" id=\"form-validation\">Form validation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#form-validation\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Validation is an integral part of managing any set of forms. Whether you’re checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators.</p>\n<ul>\n<li><strong>Reactive forms</strong> define custom validators as <strong>functions</strong> that receive a control to validate.</li>\n<li><strong>Template-driven forms</strong> are tied to template <strong>directives</strong>, and must provide custom validator directives that wrap validation functions.</li>\n</ul>\n<p translation-origin=\"off\">For more on form validation, see the <a href=\"guide/form-validation\">Form Validation</a> guide.</p>\n<h2 translation-origin=\"off\" id=\"testing\">Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Testing also plays a large part in complex applications and an easier testing strategy is always welcomed. One difference in testing reactive forms and template-driven forms is their reliance on rendering the UI in order to perform assertions based on form control and form field changes. The following examples demonstrate the process of testing forms with reactive and template-driven forms.</p>\n<h3 translation-origin=\"off\" id=\"testing-reactive-forms\">Testing reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">Reactive forms provide a relatively easy testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI. In these set of tests, controls and data are queried and manipulated through the control without interacting with the change detection cycle.</p>\n<p translation-origin=\"off\">The following tests use the favorite color components mentioned earlier to verify the view to model and model to view data flows for a reactive form.</p>\n<p translation-origin=\"off\">The following test verifies the view to model data flow:</p>\n<code-example path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" region=\"view-to-model\" header=\"Favorite color test - view to model\">\nit('should <a href=\"api/forms/NgModel#update\" class=\"code-anchor\">update</a> the value of the input field', () => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});\n\n</code-example>\n<p translation-origin=\"off\">The steps performed in the view to model test.</p>\n<ol>\n<li>Query the view for the form input element, and create a custom \"input\" event for the test.</li>\n<li>Set the new value for the input is set to <em>Red</em>, and dispatch the \"input\" event on the form input element.</li>\n<li>Assert that the <code>favoriteColor</code> <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance value matches the value from the input.</li>\n</ol>\n<p translation-origin=\"off\">The following test verifies the model to view data flow:</p>\n<code-example path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" region=\"model-to-view\" header=\"Favorite color test - model to view\">\nit('should <a href=\"api/forms/NgModel#update\" class=\"code-anchor\">update</a> the value in the control', () => {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});\n\n</code-example>\n<p translation-origin=\"off\">The steps performed in the model to view test.</p>\n<ol>\n<li>Use the <code>favoriteColor</code> <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance to set the new value.</li>\n<li>Query the view for the form input element.</li>\n<li>Assert that the new value set on the control matches the value in the input.</li>\n</ol>\n<h3 translation-origin=\"off\" id=\"testing-template-driven-forms\">Testing template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-origin=\"off\">Writing tests with template-driven forms requires more detailed knowledge of the change detection process and how directives run on each cycle to ensure elements are queried, tested, or changed at the correct time.</p>\n<p translation-origin=\"off\">The following tests use the favorite color components mentioned earlier to verify the view to model and model to view data flows for a template-driven form.</p>\n<p translation-origin=\"off\">The following test verifies the view to model data flow:</p>\n<code-example path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" region=\"view-to-model\" header=\"Favorite color test - view to model\">\nit('should <a href=\"api/forms/NgModel#update\" class=\"code-anchor\">update</a> the favorite color in the component', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  fixture.detectChanges();\n\n  expect(component.favoriteColor).toEqual('Red');\n}));\n\n</code-example>\n<p translation-origin=\"off\">The steps performed in the view to model test.</p>\n<ol>\n<li>Query the view for the form input element, and create a custom \"input\" event for the test.</li>\n<li>Set the new value for the input is set to <em>Red</em>, and dispatch the \"input\" event on the form input element.</li>\n<li>Run change detection through the test fixture.</li>\n<li>Assert that the component <code>favoriteColor</code> property value matches the value from the input.</li>\n</ol>\n<p translation-origin=\"off\">The following test verifies the model to view data flow:</p>\n<code-example path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" region=\"model-to-view\" header=\"Favorite color test - model to view\">\nit('should <a href=\"api/forms/NgModel#update\" class=\"code-anchor\">update</a> the favorite color on the input field', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() => {\n  component.favoriteColor = 'Blue';\n\n  fixture.detectChanges();\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n}));\n\n</code-example>\n<p translation-origin=\"off\">The steps performed in the model to view test.</p>\n<ol>\n<li>Use the component instance to set the value of <code>favoriteColor</code> property.</li>\n<li>Run change detection through the test fixture.</li>\n<li>Use the <code><a href=\"api/core/ApplicationRef#tick\" class=\"code-anchor\">tick()</a></code> method to simulate passage of time within the <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> task.</li>\n<li>Query the view for the form input element.</li>\n<li>Assert that the input value matches the <code>favoriteColor</code> value property in the component instance.</li>\n</ol>\n<h2 translation-origin=\"off\" id=\"mutability\">Mutability<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#mutability\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">How changes are tracked plays a role in the efficiency of your application.</p>\n<ul>\n<li><strong>Reactive forms</strong> keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance returns a new data model rather than updating the data model directly. This gives you the ability track unique changes to the data model through the control's observable. This allows change detection to be more efficient because it only needs to update on unique changes. It also follows reactive patterns that integrate with observable operators to transform data.</li>\n<li><strong>Template-driven</strong> forms rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required.</li>\n</ul>\n<p translation-origin=\"off\">The difference is demonstrated in the examples above using the <strong>favorite color</strong> input element. </p>\n<ul>\n<li>With reactive forms, the <strong><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance</strong> always returns a new value when the control's value is updated.</li>\n<li>With template-driven forms, the <strong>favorite color property</strong> is always modified to its new value.</li>\n</ul>\n<h2 translation-origin=\"off\" id=\"scalability\">Scalability<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#scalability\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">If forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical.</p>\n<ul>\n<li><strong>Reactive forms</strong> make creating large scale forms easier by providing access to low-level APIs and synchronous access to the form model.</li>\n<li><strong>Template-driven</strong> forms focus on simple scenarios, are not as reusable, abstract away the low-level APIs and access to the form model is  provided asynchronously. The abstraction with template-driven forms surfaces in testing also, where testing reactive forms requires less setup and no dependence on the change detection cycle when updating and validating the form and data models during testing.</li>\n</ul>\n<h2 translation-origin=\"off\" id=\"final-thoughts\">Final Thoughts<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#final-thoughts\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">Choosing a strategy begins with understanding the strengths and weaknesses of the options presented. Low-level API and form model access, predictability, mutability, straightforward validation and testing strategies, and scalability are all important consideration in choosing the infrastructure you use when building your forms in Angular. Template-driven forms are similar to patterns in AngularJS, but they have limitations given the criteria of many modern, large-scale Angular apps. Reactive forms integrate with reactive patterns already present in other areas of the Angular architecture, and complement those requirements well. Those limitations are alleviated with reactive forms.</p>\n<h2 translation-origin=\"off\" id=\"next-steps\">Next Steps<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#next-steps\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-origin=\"off\">The following guides are the next steps in the learning process.</p>\n<p translation-origin=\"off\">To learn more about reactive forms, see the following guides:</p>\n<ul>\n<li><a href=\"guide/reactive-forms\">Reactive Forms</a></li>\n<li><a href=\"guide/form-validation#reactive-form-validation\">Form Validation</a></li>\n<li><a href=\"guide/dynamic-form\">Dynamic forms</a></li>\n</ul>\n<p translation-origin=\"off\">To learn more about template-driven forms, see the following guides:</p>\n<ul>\n<li><a href=\"guide/forms\">Template-driven Forms</a></li>\n<li><a href=\"guide/form-validation#template-driven-validation\">Form Validation</a></li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - api/forms\n - guide/reactive-forms\n-->\n<!-- links from this doc:\n - api/core/ApplicationRef#tick\n - api/core/Component\n - api/core/Component#template\n - api/core/testing/fakeAsync\n - api/core/testing/tick\n - api/forms/ControlValueAccessor\n - api/forms/FormArray\n - api/forms/FormControl\n - api/forms/FormControlDirective\n - api/forms/FormGroup\n - api/forms/NgModel\n - api/forms/NgModel#update\n - api/forms/NgModel#viewToModelUpdate\n - guide/dynamic-form\n - guide/form-validation\n - guide/form-validation#reactive-form-validation\n - guide/form-validation#template-driven-validation\n - guide/forms\n - guide/forms-overview#common-foundation\n - guide/forms-overview#data-flow-in-forms\n - guide/forms-overview#data-flow-in-reactive-forms\n - guide/forms-overview#data-flow-in-template-driven-forms\n - guide/forms-overview#final-thoughts\n - guide/forms-overview#form-validation\n - guide/forms-overview#introduction-to-forms-in-angular\n - guide/forms-overview#key-differences\n - guide/forms-overview#mutability\n - guide/forms-overview#next-steps\n - guide/forms-overview#scalability\n - guide/forms-overview#setup-in-reactive-forms\n - guide/forms-overview#setup-in-template-driven-forms\n - guide/forms-overview#setup-the-form-model\n - guide/forms-overview#testing\n - guide/forms-overview#testing-reactive-forms\n - guide/forms-overview#testing-template-driven-forms\n - guide/reactive-forms\n - https://github.com/angular/angular/edit/master/aio/content/guide/forms-overview.md?message=docs%3A%20describe%20your%20change...\n-->"
}