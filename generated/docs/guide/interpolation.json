{
  "id": "guide/interpolation",
  "title": "Interpolation and template expressions",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/interpolation.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"interpolation-and-template-expressions\" translation-result=\"on\">插值与模板表达式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#interpolation-and-template-expressions\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"interpolation-and-template-expressions\">Interpolation and template expressions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#interpolation-and-template-expressions\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">插值能让你把计算后的字符串合并到 HTML 元素标签之间和属性赋值语句内的文本中。模板表达式则是用来供你求出这些字符串的。</p><p translation-origin=\"off\">Interpolation allows you to incorporate calculated strings into the text\nbetween HTML element tags and within attribute assignments. Template\nexpressions are what you use to calculate those strings.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">要了解本指南中涉及的语法和代码片段，请参阅 <live-example></live-example>。</p><p translation-origin=\"off\">See the <live-example></live-example> for all of\nthe syntax and code snippets in this guide.</p>\n\n</div>\n<h2 id=\"interpolation-\" translation-result=\"on\">插值 <code>{{...}}</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#interpolation-\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"interpolation-\">Interpolation <code>{{...}}</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#interpolation-\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">所谓 \"插值\" 是指将表达式嵌入到标记文本中。\n默认情况下，插值会用双花括号 <code>{{</code> 和 <code>}}</code> 作为分隔符。</p><p translation-origin=\"off\">Interpolation refers to embedding expressions into marked up text.\nBy default, interpolation uses as its delimiter the double curly braces, <code>{{</code> and <code>}}</code>.</p>\n\n<p translation-result=\"on\">在下面的代码片段中，<code>{{ currentCustomer }}</code> 就是插值的例子。</p><p translation-origin=\"off\">In the following snippet, <code>{{ currentCustomer }}</code> is an example of interpolation.</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"interpolation-example1\" header=\"src/app/app.component.html\">\n&#x3C;h3>Current customer: {{ currentCustomer }}&#x3C;/h3>\n\n</code-example>\n<p translation-result=\"on\">花括号之间的文本通常是组件属性的名字。Angular 会把这个名字替换为响应组件属性的字符串值。</p><p translation-origin=\"off\">The text between the braces is often the name of a component\nproperty. Angular replaces that name with the\nstring value of the corresponding component property.</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-property\" header=\"src/app/app.component.html\">\n&#x3C;p>{{title}}&#x3C;/p>\n&#x3C;div>&#x3C;img src=\"{{itemImageUrl}}\">&#x3C;/div>\n\n</code-example>\n<p translation-result=\"on\">在上面的示例中，Angular 计算 <code>title</code> 和 <code>itemImageUrl</code> 属性并填充空白，首先显示一些标题文本，然后显示图像。</p><p translation-origin=\"off\">In the example above, Angular evaluates the <code>title</code> and <code>itemImageUrl</code> properties\nand fills in the blanks, first displaying some title text and then an image.</p>\n\n<p translation-result=\"on\">一般来说，括号间的素材是一个<strong>模板表达式</strong>，Angular 先<strong>对它求值</strong>，再把它<strong>转换成字符串</strong>。\n下列插值通过把括号中的两个数字相加说明了这一点：</p><p translation-origin=\"off\">More generally, the text between the braces is a <strong>template expression</strong>\nthat Angular first <strong>evaluates</strong> and then <strong>converts to a string</strong>.\nThe following interpolation illustrates the point by adding two numbers:</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"convert-string\" header=\"src/app/app.component.html\">\n&#x3C;!-- \"The sum of 1 + 1 is 2\" -->\n&#x3C;p>The sum of 1 + 1 is {{1 + 1}}.&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">这个表达式可以调用宿主组件的方法，就像下面用的 <code>getVal()</code>：</p><p translation-origin=\"off\">The expression can invoke methods of the host component such as <code>getVal()</code> in\nthe following example:</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"invoke-method\" header=\"src/app/app.component.html\">\n&#x3C;!-- \"The sum of 1 + 1 is not 4\" -->\n&#x3C;p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}.&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">Angular 对所有双花括号中的表达式求值，把求值的结果转换成字符串，并把它们跟相邻的字符串字面量连接起来。最后，把这个组合出来的插值结果赋给<strong>元素或指令的属性</strong>。</p><p translation-origin=\"off\">Angular evaluates all expressions in double curly braces,\nconverts the expression results to strings, and links them with neighboring literal strings. Finally,\nit assigns this composite interpolated result to an <strong>element or directive property</strong>.</p>\n\n<p translation-result=\"on\">你看上去似乎正在将结果插入元素标签之间，并将其赋值给属性。\n但实际上，插值是一种特殊语法，Angular 会将其转换为<em>属性绑定</em>。</p><p translation-origin=\"off\">You appear to be inserting the result between element tags and assigning it to attributes.\nHowever, interpolation is a special syntax that Angular converts into a <em>property binding</em>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你想用别的分隔符来代替 <code>{{</code> 和 <code>}}</code>，也可以通过 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元数据中的 <a href=\"api/core/Component#interpolation\">interpolation</a> 选项来配置插值分隔符。</p><p translation-origin=\"off\">If you'd like to use something other than <code>{{</code> and <code>}}</code>, you can\nconfigure the interpolation delimiter via the\n<a href=\"api/core/Component#interpolation\">interpolation</a>\noption in the <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> metadata.</p>\n\n</div>\n<h2 id=\"template-expressions\" translation-result=\"on\">模板表达式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#template-expressions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"template-expressions\">Template expressions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#template-expressions\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">模板<strong>表达式</strong>会产生一个值，并出现在双花括号 <code>{{ }}</code> 中。\nAngular 执行这个表达式，并把它赋值给绑定目标的属性，这个绑定目标可能是 HTML 元素、组件或指令。</p><p translation-origin=\"off\">A template <strong>expression</strong> produces a value and appears within the double\ncurly braces, <code>{{ }}</code>.\nAngular executes the expression and assigns it to a property of a binding target;\nthe target could be an HTML element, a component, or a directive.</p>\n\n<p translation-result=\"on\"><code>{{1 + 1}}</code> 中所包含的模板表达式是 <code>1 + 1</code>。\n在属性绑定中会再次看到模板表达式，它出现在 <code>=</code> 右侧的引号中，就像这样：<code>[property]=\"expression\"</code>。</p><p translation-origin=\"off\">The interpolation braces in <code>{{1 + 1}}</code> surround the template expression <code>1 + 1</code>.\nIn the property binding,\na template expression appears in quotes to the right of the <code>=</code> symbol as in <code>[property]=\"expression\"</code>.</p>\n\n<p translation-result=\"on\">在语法上，模板表达式与 JavaScript 很像。很多 JavaScript 表达式都是合法的模板表达式，但也有一些例外。</p><p translation-origin=\"off\">In terms of syntax, template expressions are similar to JavaScript.\nMany JavaScript expressions are legal template expressions, with a few exceptions.</p>\n\n<p translation-result=\"on\">你不能使用那些具有或可能引发副作用的 JavaScript 表达式，包括：</p><p translation-origin=\"off\">You can't use JavaScript expressions that have or promote side effects,\nincluding:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 赋值 (<code>=</code>, <code>+=</code>, <code>-=</code>, <code>...</code>)</p><p translation-origin=\"off\">Assignments (<code>=</code>, <code>+=</code>, <code>-=</code>, <code>...</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <code>new</code>、<code>typeof</code>、<code>instanceof</code> 等运算符。</p><p translation-origin=\"off\">Operators such as <code>new</code>, <code>typeof</code>, <code>instanceof</code>, etc.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 使用 <code>;</code> 或 <code>,</code> 串联起来的表达式</p><p translation-origin=\"off\">Chaining expressions with <code>;</code> or <code>,</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 自增和自减运算符：<code>++</code> 和 <code>--</code></p><p translation-origin=\"off\">The increment and decrement operators <code>++</code> and <code>--</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 一些 ES2015+ 版本的运算符</p><p translation-origin=\"off\">Some of the ES2015+ operators</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">和 JavaScript 语法的其它显著差异包括：</p><p translation-origin=\"off\">Other notable differences from JavaScript syntax include:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 不支持位运算，比如 <code>|</code> 和 <code>&#x26;</code></p><p translation-origin=\"off\">No support for the bitwise operators such as <code>|</code> and <code>&#x26;</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">新的<a href=\"guide/template-expression-operators\">模板表达式运算符</a>，例如 <code>|</code>，<code>?.</code> 和 <code>!</code></p><p translation-origin=\"off\">New <a href=\"guide/template-expression-operators\">template expression operators</a>, such as <code>|</code>, <code>?.</code> and <code>!</code></p>\n\n</li>\n</ul>\n<h2 id=\"expression-context\" translation-result=\"on\">表达式上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#expression-context\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"expression-context\">Expression context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#expression-context\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">典型的<em>表达式上下文</em>就是这个<strong>组件实例</strong>，它是各种绑定值的来源。\n在下面的代码片段中，双花括号中的 <code>recommended</code> 和引号中的 <code>itemImageUrl2</code> 所引用的都是 <code>AppComponent</code> 中的属性。</p><p translation-origin=\"off\">The <em>expression context</em> is typically the <em>component</em> instance.\nIn the following snippets, the <code>recommended</code> within double curly braces and the\n<code>itemImageUrl2</code> in quotes refer to properties of the <code>AppComponent</code>.</p>\n\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"component-context\" header=\"src/app/app.component.html\">\n&#x3C;h4>{{recommended}}&#x3C;/h4>\n&#x3C;img [src]=\"itemImageUrl2\">\n\n</code-example>\n<p translation-result=\"on\">表达式也可以引用模板中的上下文属性，例如模板输入变量，</p><p translation-origin=\"off\">An expression may also refer to properties of the <em>template's</em> context\nsuch as a template input variable,</p>\n\n<!-- link to built-in-directives#template-input-variables -->\n<p translation-result=\"on\"><code>let customer</code>，或模板引用变量 <code>#customerInput</code>。</p><p translation-origin=\"off\"><code>let customer</code>, or a template reference variable, <code>#customerInput</code>.</p>\n\n<!-- link to guide/template-ref-variables -->\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-input-variable\" header=\"src/app/app.component.html (template input variable)\">\n&#x3C;ul>\n  &#x3C;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let customer of customers\">{{customer.name}}&#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<code-example path=\"interpolation/src/app/app.component.html\" region=\"template-reference-variable\" header=\"src/app/app.component.html (template reference variable)\">\n&#x3C;label><a href=\"api/core/Type\" class=\"code-anchor\">Type</a> something:\n  &#x3C;input #customerInput>{{customerInput.value}}\n&#x3C;/label>\n\n</code-example>\n<p translation-result=\"on\">表达式中的上下文变量是由<em>模板变量</em>、指令的<em>上下文变量</em>（如果有）和组件的<em>成员</em>叠加而成的。\n如果你要引用的变量名存在于一个以上的命名空间中，那么，模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员。</p><p translation-origin=\"off\">The context for terms in an expression is a blend of the <em>template variables</em>,\nthe directive's <em>context</em> object (if it has one), and the component's <em>members</em>.\nIf you reference a name that belongs to more than one of these namespaces,\nthe template variable name takes precedence, followed by a name in the directive's <em>context</em>,\nand, lastly, the component's member names.</p>\n\n<p translation-result=\"on\">上一个例子中就体现了这种命名冲突。组件具有一个名叫 <code>customer</code> 的属性，而 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 声明了一个也叫 <code>customer</code> 的模板变量。</p><p translation-origin=\"off\">The previous example presents such a name collision. The component has a <code>customer</code>\nproperty and the <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> defines a <code>customer</code> template variable.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在 <code>{{customer.name}}</code> 表达式中的 <code>customer</code> 实际引用的是模板变量，而不是组件的属性。</p><p translation-origin=\"off\">The <code>customer</code> in <code>{{customer.name}}</code>\nrefers to the template input variable, not the component's property.</p>\n\n<p translation-result=\"on\">模板表达式不能引用全局命名空间中的任何东西，比如 <code>window</code> 或 <code>document</code>。它们也不能调用 <code>console.log</code> 或 <code>Math.max</code>。\n它们只能引用表达式上下文中的成员。</p><p translation-origin=\"off\">Template expressions cannot refer to anything in\nthe global namespace, except <code>undefined</code>. They can't refer to\n<code>window</code> or <code>document</code>. Additionally, they\ncan't call <code>console.log()</code> or <code>Math.max()</code> and they are restricted to referencing\nmembers of the expression context.</p>\n\n</div>\n<h2 id=\"expression-guidelines\" translation-result=\"on\">表达式使用指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#expression-guidelines\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"expression-guidelines\">Expression guidelines<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#expression-guidelines\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当使用模板表达式时，请遵循下列指南：</p><p translation-origin=\"off\">When using template expressions follow these guidelines:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/interpolation#simplicity\">非常简单</a></p><p translation-origin=\"off\"><a href=\"guide/interpolation#simplicity\">Simplicity</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/interpolation#quick-execution\">执行迅速</a></p><p translation-origin=\"off\"><a href=\"guide/interpolation#quick-execution\">Quick execution</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/interpolation#no-visible-side-effects\">没有可见的副作用</a></p><p translation-origin=\"off\"><a href=\"guide/interpolation#no-visible-side-effects\">No visible side effects</a></p>\n\n</li>\n</ul>\n<h3 id=\"simplicity\" translation-result=\"on\">简单<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#simplicity\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"simplicity\">Simplicity<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#simplicity\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">虽然也可以写复杂的模板表达式，不过最好避免那样做。</p><p translation-origin=\"off\">Although it's possible to write complex template expressions, it's a better\npractice to avoid them.</p>\n\n<p translation-result=\"on\">属性名或方法调用应该是常态，但偶然使用逻辑取反 <code>!</code> 也是可以的。\n其它情况下，应该把应用程序和业务逻辑限制在组件中，这样它才能更容易开发和测试。</p><p translation-origin=\"off\">A property name or method call should be the norm, but an occasional Boolean negation, <code>!</code>, is OK.\nOtherwise, confine application and business logic to the component,\nwhere it is easier to develop and test.</p>\n\n<h3 id=\"quick-execution\" translation-result=\"on\">快速执行<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#quick-execution\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"quick-execution\">Quick execution<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#quick-execution\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 会在每个变更检测周期后执行模板表达式。\n变更检测周期会被多种异步活动触发，比如 Promise 解析、HTTP 结果、定时器时间、按键或鼠标移动。</p><p translation-origin=\"off\">Angular executes template expressions after every change detection cycle.\nChange detection cycles are triggered by many asynchronous activities such as\npromise resolutions, HTTP results, timer events, key presses and mouse moves.</p>\n\n<p translation-result=\"on\">表达式应该快速结束，否则用户就会感到拖沓，特别是在较慢的设备上。\n当计算代价较高时，应该考虑缓存那些从其它值计算得出的值。</p><p translation-origin=\"off\">Expressions should finish quickly or the user experience may drag, especially on slower devices.\nConsider caching values when their computation is expensive.</p>\n\n<h3 id=\"no-visible-side-effects\" translation-result=\"on\">没有可见的副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#no-visible-side-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"no-visible-side-effects\">No visible side effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/interpolation#no-visible-side-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">模板表达式除了目标属性的值以外，不应该改变应用的任何状态。</p><p translation-origin=\"off\">A template expression should not change any application state other than the value of the\ntarget property.</p>\n\n<p translation-result=\"on\">这条规则是 Angular “单向数据流”策略的基础。\n永远不用担心读取组件值可能改变另外的显示值。\n在一次单独的渲染过程中，视图应该总是稳定的。</p><p translation-origin=\"off\">This rule is essential to Angular's \"unidirectional data flow\" policy.\nYou should never worry that reading a component value might change some other displayed value.\nThe view should be stable throughout a single rendering pass.</p>\n\n<p translation-result=\"on\"><a href=\"https://en.wikipedia.org/wiki/Idempotence\">幂等</a>的表达式是最理想的，因为它没有副作用，并且可以提高 Angular 的变更检测性能。\n用 Angular 术语来说，幂等表达式总会返回<em>完全相同的东西</em>，除非其依赖值之一发生了变化。</p><p translation-origin=\"off\">An <a href=\"https://en.wikipedia.org/wiki/Idempotence\">idempotent</a> expression is ideal because\nit is free of side effects and improves Angular's change detection performance.\nIn Angular terms, an idempotent expression always returns\n<em>exactly the same thing</em> until one of its dependent values changes.</p>\n\n<p translation-result=\"on\">在单独的一次事件循环中，被依赖的值不应该改变。\n如果幂等的表达式返回一个字符串或数字，连续调用它两次，也应该返回相同的字符串或数字。\n如果幂等的表达式返回一个对象（包括 <code>Date</code> 或 <code>Array</code>），连续调用它两次，也应该返回同一个对象的<em>引用</em>。</p><p translation-origin=\"off\">Dependent values should not change during a single turn of the event loop.\nIf an idempotent expression returns a string or a number, it returns the same string or number when called twice in a row. If the expression returns an object, including an <code>array</code>, it returns the same object <em>reference</em> when called twice in a row.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">对于 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>，这种行为有一个例外。<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 具有 <code>trackBy</code> 功能，在迭代对象时它可以处理对象的相等性。详情参见 <a href=\"guide/built-in-directives#ngfor-with-trackby\">带 <code>trackBy</code> 的 *ngFor</a>。</p><p translation-origin=\"off\">There is one exception to this behavior that applies to <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>. <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> has <code>trackBy</code> functionality that can deal with referential inequality of objects when iterating over them. See <a href=\"guide/built-in-directives#ngfor-with-trackby\">*ngFor with <code>trackBy</code></a> for details.</p>\n\n</div>\n\n</div>\n\n<!-- links to this doc:\n - guide/ajs-quick-reference\n - guide/architecture-components\n - guide/built-in-directives\n - guide/example-apps-list\n - guide/glossary\n - guide/property-binding\n - guide/structural-directives\n - guide/template-statements\n - guide/template-syntax\n - guide/user-input\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/Component\n - api/core/Component#interpolation\n - api/core/Type\n - guide/built-in-directives#ngfor-with-trackby\n - guide/interpolation#expression-context\n - guide/interpolation#expression-guidelines\n - guide/interpolation#interpolation-\n - guide/interpolation#interpolation-and-template-expressions\n - guide/interpolation#no-visible-side-effects\n - guide/interpolation#quick-execution\n - guide/interpolation#simplicity\n - guide/interpolation#template-expressions\n - guide/template-expression-operators\n - https://en.wikipedia.org/wiki/Idempotence\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/interpolation.md?message=docs%3A%20请简述你的修改...\n-->"
}